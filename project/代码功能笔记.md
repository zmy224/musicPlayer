## vue动态组件使用—tab选项卡

tab选项卡在项目中经常使用
动态组件的使用请看vue官网
实例

```
   <!-- tab -->
   <ul class="tab">
     <li @click='tabTaggle("recommend")'>推荐</li>
     <li @click='tabTaggle("hh")'>人气</li>
     <li @click='tabTaggle("singer")'>歌手</li>
     <li @click='tabTaggle("music")'>音乐</li>
   </ul>
   <!-- 动态组件 -->
   <component :is="currentTab"></component>
js
<script>
import headerNav from '../components/home/header.vue'
import recommend from  './recommend.vue'
import singer from  './singer.vue'
export default {
 components:{
   headerNav,
   recommend,
   singer
 },
 data(){
   return  {
     currentTab:'recommend'
   }
 },
 methods: {
   tabTaggle(taggleMenu){
     this.currentTab=taggleMenu;
   }
 },
}

```

## jsonp原理

由于浏览器的同源策略，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。

同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。现在知道了**同**源策略，那我们就来看下jsonp是如何突破同源策略的限制实现跨域的

首先，不知道大家有没有注意，不管是我们的script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制，比如我们有可能使用一个网络上的图片，就可以请求得到

可以看到，确实是个get请求无疑。同理img标签的src和link标签的href也会发送一个get请求去请求静态资源。那么我们通过这点，是不是发现了点什么，这些标签的src和link属性，并没有受同源策略的限制。说到这里jsonp的实现原理就浮出水面了。

jsonp就是使用同源策略这一“漏洞”，实现的跨域请求（这也是jsonp跨域只能用get请求的原因所在）。想象一下，既然是个get请求，那么服务端一定可以接收到，并做出反馈。ok，知道这两点之后，我们开始具体使用jsonp进行跨域请求。

```
<button id="btn">点击</button>
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
  <script>
    $('#btn').click(function(){
			var frame = document.createElement('script');
			frame.src = 'http://localhost:3000/article-list?name=leo&age=30&callback=func';
			$('body').append(frame);
		});
		
		function func(res){
			alert(res.message+res.name+'你已经'+res.age+'岁了');
		}
  </script>
```

需要注意的是，callback参数定义的方法是需要前后端定义好的，具体什么名字，商讨好就可以了。其实jsonp的整个过程就类似于前端声明好一个函数，后端返回执行函数。执行函数参数中携带所需的数据，整个过程实际非常简单易懂

https://blog.csdn.net/badmoonc/article/details/82289252

## 简易轮播图的实现

轮播图在实际开发中非常常见，这边基于vue简易写了一个swiper组件这边样式由于时间问题就随意了

```
<template>
    <!-- 轮播图 -->
    <div class="swiper" @mouseleave="mouseleave"  @mouseenter='mouseenter'>
    <div class="img" >
       <img @click="linkTo(item.linkUrl)" v-for="(item ,index) in  swipeList" :key ='item.id' :src="item.picUrl" alt=""  v-show="index==currentIndex">
    </div>

    <!--底部小圈圈 -->
    <div class="circle" >
        <span v-for="(item,index) in  swipeList.length" :key='index' :class="{'current':index==currentIndex}"  @click="swithToCurrent(index)"></span>
    </div>
    <!-- 上一张 下一张按钮 -->
    <span  class="pre" @click='preEvent'></span>
    <span  class="next" @click="nextEvent"></span>
    </div>
</template>

<script>
export default {
    props:{
        swipeList:Array,
        default:[]
    },

    mounted(){
        const _this = this;
      this.timer= setInterval(function(){
          _this.nextEvent();
        },5000)
    },
    data(){
        return  {
            currentIndex:0,
            timer:null,
        }
    },
    methods: {
        // 下一张
      nextEvent(){
       this.currentIndex+=1;
       if(this.currentIndex>=this.swipeList.length){
           this.currentIndex=0;
       }
    },
    
    // 上一张
      preEvent(){
           this.currentIndex-=1;
           if(this.currentIndex<0){
               this.currentIndex= this.swipeList.length-1;
           }
      },
      //  小圈圈事件
      swithToCurrent(index){
          this.currentIndex= index;
      },
      //  鼠标离开开启定时器
       mouseleave(){
             const _this= this
            console.log('鼠标离开了')
           this.timer= setInterval(function(){
                    _this.nextEvent();
           },5000)
       },
       mouseenter(){
             const _this= this
             console.log('鼠标进入了')
            this.timer &&clearInterval(_this.timer)
       },
       //  点击图片跳转
       linkTo(url){
           window.location.href= url
       }
    },

}
</script>

<style>
.swiper{
    width:100%;
    height :160px;
    background-color: blanchedalmond;
    position: relative;
}
.swiper .img {
    width:100%;
    position: relative;
    height: 160px;
    transition: width 2s ;
}
.swiper .img  img {
    width:100%;
     height: 160px;
    position: absolute;
    left:0;
    top:0
}
.circle {
    position: absolute;
    bottom :5px;
    left:30%;
}
.circle span {
    width:15px;
    height: 15px;
    background:rgb(158, 158, 157);
    opacity: 0.7;
    display: inline-block;
    margin-left:15px;
    border-radius: 50%;
}
.circle .current {
    background-color: orange;
  
}
  .pre{
    position: absolute;
    width:30px;
    height:30px;
    border-radius: 50%;
    background-color: orange;
    left:0;
    top:48%;
}
 .next {
    position: absolute;
    width:30px;
    height:30px;
    border-radius: 50%;
    background-color: orange;
    top:48%;
    right:0;
}
</style>
```

## 动态传属性使用v-bind="$attrs" 和 v-on="$listeners"

(https://www.cnblogs.com/bobo1/p/12600904.html)当我们去二次封装别人组件时，可能别人组件上有很多属性，我们不想再次重写一遍

这时候就可以使用`v-bind="$attrs" 和 v-on="$listeners"`。这是vue 2.4 版本提供

 `vm.$attrs` 是一个属性，其包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。这些未识别的属性可以通过 `v-bind="$attrs"` 传入内部组件。未识别的事件可通过`v-on="$listeners"`传入。

举个例子，比如我创建了我的按钮组件`myButton`，封装了 element-ui 的 el-button 组件（其实什么事情都没做），在使用组件 `<my-button />`时，就可以直接在组件上使用 el-button 的属性,不被 prop 识别的属性会传入到 el-button 元素上非常的方便！