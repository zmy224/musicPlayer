## vue动态组件使用—tab选项卡

tab选项卡在项目中经常使用
动态组件的使用请看vue官网
实例

```
   <!-- tab -->
   <ul class="tab">
     <li @click='tabTaggle("recommend")'>推荐</li>
     <li @click='tabTaggle("hh")'>人气</li>
     <li @click='tabTaggle("singer")'>歌手</li>
     <li @click='tabTaggle("music")'>音乐</li>
   </ul>
   <!-- 动态组件 -->
   <component :is="currentTab"></component>
js
<script>
import headerNav from '../components/home/header.vue'
import recommend from  './recommend.vue'
import singer from  './singer.vue'
export default {
 components:{
   headerNav,
   recommend,
   singer
 },
 data(){
   return  {
     currentTab:'recommend'
   }
 },
 methods: {
   tabTaggle(taggleMenu){
     this.currentTab=taggleMenu;
   }
 },
}

```

## jsonp原理

由于浏览器的同源策略，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。

同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。现在知道了**同**源策略，那我们就来看下jsonp是如何突破同源策略的限制实现跨域的

首先，不知道大家有没有注意，不管是我们的script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制，比如我们有可能使用一个网络上的图片，就可以请求得到

可以看到，确实是个get请求无疑。同理img标签的src和link标签的href也会发送一个get请求去请求静态资源。那么我们通过这点，是不是发现了点什么，这些标签的src和link属性，并没有受同源策略的限制。说到这里jsonp的实现原理就浮出水面了。

jsonp就是使用同源策略这一“漏洞”，实现的跨域请求（这也是jsonp跨域只能用get请求的原因所在）。想象一下，既然是个get请求，那么服务端一定可以接收到，并做出反馈。ok，知道这两点之后，我们开始具体使用jsonp进行跨域请求。

```
<button id="btn">点击</button>
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
  <script>
    $('#btn').click(function(){
			var frame = document.createElement('script');
			frame.src = 'http://localhost:3000/article-list?name=leo&age=30&callback=func';
			$('body').append(frame);
		});
		
		function func(res){
			alert(res.message+res.name+'你已经'+res.age+'岁了');
		}
  </script>
```

需要注意的是，callback参数定义的方法是需要前后端定义好的，具体什么名字，商讨好就可以了。其实jsonp的整个过程就类似于前端声明好一个函数，后端返回执行函数。执行函数参数中携带所需的数据，整个过程实际非常简单易懂

https://blog.csdn.net/badmoonc/article/details/82289252

## 简易轮播图的实现

轮播图在实际开发中非常常见，这边基于vue简易写了一个swiper组件这边样式由于时间问题就随意了

```
<template>
    <!-- 轮播图 -->
    <div class="swiper" @mouseleave="mouseleave"  @mouseenter='mouseenter'>
    <div class="img" >
       <img @click="linkTo(item.linkUrl)" v-for="(item ,index) in  swipeList" :key ='item.id' :src="item.picUrl" alt=""  v-show="index==currentIndex">
    </div>

    <!--底部小圈圈 -->
    <div class="circle" >
        <span v-for="(item,index) in  swipeList.length" :key='index' :class="{'current':index==currentIndex}"  @click="swithToCurrent(index)"></span>
    </div>
    <!-- 上一张 下一张按钮 -->
    <span  class="pre" @click='preEvent'></span>
    <span  class="next" @click="nextEvent"></span>
    </div>
</template>

<script>
export default {
    props:{
        swipeList:Array,
        default:[]
    },

    mounted(){
        const _this = this;
      this.timer= setInterval(function(){
          _this.nextEvent();
        },5000)
    },
    data(){
        return  {
            currentIndex:0,
            timer:null,
        }
    },
    methods: {
        // 下一张
      nextEvent(){
       this.currentIndex+=1;
       if(this.currentIndex>=this.swipeList.length){
           this.currentIndex=0;
       }
    },
    
    // 上一张
      preEvent(){
           this.currentIndex-=1;
           if(this.currentIndex<0){
               this.currentIndex= this.swipeList.length-1;
           }
      },
      //  小圈圈事件
      swithToCurrent(index){
          this.currentIndex= index;
      },
      //  鼠标离开开启定时器
       mouseleave(){
             const _this= this
            console.log('鼠标离开了')
           this.timer= setInterval(function(){
                    _this.nextEvent();
           },5000)
       },
       mouseenter(){
             const _this= this
             console.log('鼠标进入了')
            this.timer &&clearInterval(_this.timer)
       },
       //  点击图片跳转
       linkTo(url){
           window.location.href= url
       }
    },

}
</script>

<style>
.swiper{
    width:100%;
    height :160px;
    background-color: blanchedalmond;
    position: relative;
}
.swiper .img {
    width:100%;
    position: relative;
    height: 160px;
    transition: width 2s ;
}
.swiper .img  img {
    width:100%;
     height: 160px;
    position: absolute;
    left:0;
    top:0
}
.circle {
    position: absolute;
    bottom :5px;
    left:30%;
}
.circle span {
    width:15px;
    height: 15px;
    background:rgb(158, 158, 157);
    opacity: 0.7;
    display: inline-block;
    margin-left:15px;
    border-radius: 50%;
}
.circle .current {
    background-color: orange;
  
}
  .pre{
    position: absolute;
    width:30px;
    height:30px;
    border-radius: 50%;
    background-color: orange;
    left:0;
    top:48%;
}
 .next {
    position: absolute;
    width:30px;
    height:30px;
    border-radius: 50%;
    background-color: orange;
    top:48%;
    right:0;
}
</style>
```

## 动态传属性使用v-bind="$attrs" 和 v-on="$listeners"

(https://www.cnblogs.com/bobo1/p/12600904.html)当我们去二次封装别人组件时，可能别人组件上有很多属性，我们不想再次重写一遍

这时候就可以使用`v-bind="$attrs" 和 v-on="$listeners"`。这是vue 2.4 版本提供

 `vm.$attrs` 是一个属性，其包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。这些未识别的属性可以通过 `v-bind="$attrs"` 传入内部组件。未识别的事件可通过`v-on="$listeners"`传入。

举个例子，比如我创建了我的按钮组件`myButton`，封装了 element-ui 的 el-button 组件（其实什么事情都没做），在使用组件 `<my-button />`时，就可以直接在组件上使用 el-button 的属性,不被 prop 识别的属性会传入到 el-button 元素上非常的方便！

scrollTop offsetTop之间的区别



每个HTML元素都具有clientHeight offsetHeight scrollHeight offsetTop scrollTop 这5个和元素高度、滚动、位置相关的属性，单凭单词很难搞清楚分别代表什么意思之间有什么区别。通过阅读它们的文档总结出规律如下：
clientHeight和offsetHeight属性和元素的滚动、位置没有关系它代表元素的高度，其中：
clientHeight：包括padding但不包括border、水平滚动条、margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素。

offsetHeight：包括padding、border、水平滚动条，但不包括margin的元素的高度。对于inline的元素这个属性一直是0，单位px，只读元素。

接下来讨论出现有滚动条时的情况：
当本元素的子元素比本元素高且overflow=scroll时，本元素会scroll，这时：
scrollHeight: 因为子元素比父元素高，父元素不想被子元素撑的一样高就显示出了滚动条，在滚动的过程中本元素有部分被隐藏了，scrollHeight代表包括当前不可见部分的元素的高度。而可见部分的高度其实就是clientHeight，也就是scrollHeight>=clientHeight恒成立。在有滚动条时讨论scrollHeight才有意义，在没有滚动条时scrollHeight==clientHeight恒成立。单位px，只读元素。scrollTop: 代表在有滚动条时，滚动条向下滚动的距离也就是元素顶部被遮住部分的高度。在没有滚动条时scrollTop==0恒成立。单位px，可读可设置。

offsetTop: 当前元素顶部距离最近父元素顶部的距离,和有没有滚动条没有关系。单位px，只读元素

# Vue 事件中心#EventBus#使用详细介绍

vue组件非常常见的有父子组件通信，兄弟组件通信。而父子组件通信就很简单，父组件会通过 `props` 向下传数据给子组件，当子组件有事情要告诉父组件时会通过 `$emit` 事件告诉父组件。今天就来说说如果两个页面没有任何引入和被引入关系，该如何通信了

果咱们的应用程序不需要类似Vuex这样的库来处理组件之间的数据通信，就可以考虑Vue中的 事件总线 ，即 **EventBus**来通信

------

`EventBus`又称为事件总线。在Vue中可以使用 `EventBus` 来作为沟通桥梁的概念，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件，所以组件都可以上下平行地通知其他组件。

## 如何使用EventBus

### 1.初始化

首先需要创建事件总线并将其导出，以便其它模块可以使用或者监听它。我们可以通过两种方式来处理。先来看第一种，新创建一个 .js 文件，比如 `event-bus.js`

```
// event-bus.js
import Vue from 'vue'
export const EventBus = new Vue()
```

实质上EventBus是一个不具备 DOM 的组件，它具有的仅仅只是它实例方法而已，因此它非常的轻便

另外一种方式，可以直接在项目中的 main.js 初始化 EventBus

> 这种方式初始化的 `EventBus`是一个 全局的事件总线 。稍后再来聊一聊全局的事件总线

**现在我们已经创建了 EventBus ，接下来你需要做到的就是在你的组件中加载它，并且调用同一个方法，就如你在父子组件中互相传递消息一样。**

### 2. 发送事件

假设你有两个Vue页面需要通信： A 和 B ，A页面 在按钮上面绑定了点击事件，发送一则消息，想通知 B页面、

```
<!-- A.vue -->
<template>
    <button @click="sendMsg()">-</button>
</template>

<script> 
import { EventBus } from "../event-bus.js";
export default {
  methods: {
    sendMsg() {
      EventBus.$emit("aMsg", '来自A页面的消息');
    }
  }
}; 
</script>
```

```
<!-- IncrementCount.vue -->
<template>
  <p>{{msg}}</p>
</template>

<script> 
import { 
  EventBus 
} from "../event-bus.js";
export default {
  data(){
    return {
      msg: ''
    }
  },
  mounted() {
    EventBus.$on("aMsg", (msg) => {
      // A发送来的消息
      this.msg = msg;
    });
  }
};
</script>
```

前面提到过，如果使用不善，`EventBus` 会是一种灾难，到底是什么样的“灾难”了？大家都知道vue是单页应用，如果你在某一个页面刷新了之后，与之相关的`EventBus`会被移除，这样就导致业务走不下去。还要就是如果业务有反复操作的页面，EventBus 在监听的时候就会触发很多次，也是一个非常大的隐患。这时候我们就需要好好处理 EventBus 在项目中的关系。通常会用到，在vue页面销毁时，同时移除EventBus`事件监听`

```
import { 
  eventBus 
} from './event-bus.js'
EventBus.$off('aMsg', {})
```

### route  router  区别



vue-router中经常会操作的两个对象$route和$router两个。

### **1、**

### **$route对象**

​        **$route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等。**

​    **1.**    **$route.path **     字符串，对应当前路由的路径，总是解析为绝对路径，如"/foo/bar"。

​    **2.**    **$route.params **     一个 key/value 对象，包含了 动态片段 和 全匹配片段，      如果没有路由参数，就是一个空对象。

​    **3.**    **$route.query **     一个 key/value 对象，表示 URL 查询参数。      例如，对于路径 /foo?user=1，则有$route.query.user == 1，      如果没有查询参数，则是个空对象。

​    **4.**    **$route.hash **     当前路由的hash值 (不带#) ，如果没有 hash 值，则为空字符串。锚点*

​    **5.**    **$route.fullPath**      完成解析后的 URL，包含查询参数和hash的完整路径。

​    **6.**    **$route.matched**      数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。

​    **7.**    **$route.name**    当前路径名字

​    **8.**    **$route.meta**  路由元信息

​    导航钩子的参数：

​    router.beforeEach((to,from, next)=>{//to 和from都是 路由信息对象,后面使用路由的钩子函数就容易理解了})

## **2、$router对象**

​        **$router对象是全局路由的实例，是router构造方法的实例。**

**路由实例方法：**

#### **1、push**

​    1.字符串this.$router.push('home')

​    2. 对象this.$router.push({path:'home'})

​    3. 命名的路由this.$router.push({name:'user',params:{userId:123}})

​    4.带查询参数，变成 /register?plan=123this.$router.push({path:'register',query:{plan:'123'}})

​    push方法其实和<router-link :to="...">是等同的。

​    注意：push方法的跳转会向 history 栈添加一个新的记录，当我们点击浏览器的返回按钮时可以看到之前的页面。

#### **2、go**

​     页面路由跳转 

​     前进或者后退this.$router.go(-1)  // 后退

#### 3、replace

​    push方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，

​    不会向 history 栈添加一个新的记录

#### 4.一般使用replace来做404页面

​    this.$router.replace('/')

​    配置路由时path有时候会加 '/' 有时候不加,以'/'开头的会被当作根路径，就不会一直嵌套之前的路径。

$router对象是全局路由的实例，是router构造方法的实例。

background-size中，100%和cover都是用于将图片扩大或者缩放来适应整个容器

background-size：100% 100%;---按容器比例撑满，图片变形；

background-size：cover;---把背景图片放大到适合元素容器的尺寸，图片比例不变，但是要注意，超出容器的部分可能会裁掉。

##### vue中的transition标签

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>


    <script src="https://unpkg.com/vue/dist/vue.js"></script>

    <!--2. 自定义两组样式，来控制transition 内部的元素实现动画-->
    <style>
        /*v-enter 是进入之前，元素的起始状态*/
        /*v-leave-to 离开之后动画的终止状态*/
        .v-enter,.v-leave-to{
            opacity:  0;/*透明度*/
            transform: translateX(150px);
        }
         /*入场(离场)动画的时间段   */
        .v-enter-active,.v-leave-active{
            transition: all 0.8s ease;

        }


        .my-enter,.my-leave-to{
            opacity:  0;/*透明度*/
            transform: translateY(70px);
        }
        .my-enter-active,.my-leave-active{
            transition: all 0.8s ease;

        }
    </style>
</head>
<body>

    <div id="app">
        <input type="button" value="toggle" @click="flag=!flag">
        <input type="button" value="toggle2" @click="flag2=!flag2">

        <!--1. 使用transition元素把需要被动画控制的元素，包裹起来-->
        <transition>
            <h3 v-if="flag">这是一个H3</h3>
        </transition>

        <transition  name="my">  <!--区分不同组织间动画-->
            <h6 v-if="flag2">这是一个H6</h6>
        </transition>
    </div>

<script>
    var vm = new Vue({
       el : '#app',
       data : {
           flag : false,
           flag2 : false,
       },
       methods : {

       },
    });

</script>
</body>
</html>

```



##### vue中使用iconfont

1. 去iconfont官网选择想要的图标下载到本地

https://www.iconfont.cn/?spm=a313x.7781069.1998910419.d4d0a486a

2.解压下载后的文件 放入到项目中

3.修改iconfont.css 中路径为相对路径

4.在main.js在中引用

5.打开demo.html  在项目中选择想要的样式类名

##### css3 元素旋转动画

```
@keyframes rotate {
 0%{
 transform: rotate(0)
 }
      
100%{
 transform: rotate(360deg)
    }
}

.play {
  .center .play{
    animation:rotate 20s linear infinite;
}
.center .pluse {
     animation-play-state: paused   //  暂停
}
}


```

